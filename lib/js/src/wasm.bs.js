// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Utils = require("./utils.bs.js");
var Leb128 = require("./leb128.bs.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function param(name, tpe) {
  return /* record */[
          /* name */name,
          /* tpe */tpe
        ];
}

function func(name, params, returns, locals, instr, $$export) {
  var numParams = List.length(params);
  var numLocals = List.length(locals);
  var localIdx = Hashtbl.create(/* None */0, numParams + numLocals | 0);
  var i = List.fold_left((function (i, p) {
          Hashtbl.add(localIdx, p[/* name */0], i);
          return i + 1 | 0;
        }), 0, params);
  List.fold_left((function (i, l) {
          Hashtbl.add(localIdx, l[/* name */0], i);
          return i + 1 | 0;
        }), i, locals);
  return /* record */[
          /* name */name,
          /* params */params,
          /* returns */returns,
          /* locals */locals,
          /* localIdx */localIdx,
          /* instr */instr,
          /* export */$$export,
          /* numParams */numParams,
          /* numLocals */numLocals,
          /* numReturns */List.length(returns)
        ];
}

function modul(funcs) {
  return /* record */[/* funcs */funcs];
}

function makeBuf(bufSize) {
  var ab = new ArrayBuffer(bufSize);
  var arr = new Uint8Array(ab);
  return /* record */[
          /* arr */arr,
          /* size */0,
          /* bufSize */bufSize,
          /* buf */ab
        ];
}

function typeCode(tpe) {
  switch (tpe) {
    case 0 : 
        return 127;
    case 1 : 
        return 126;
    case 2 : 
        return 125;
    case 3 : 
        return 124;
    case 4 : 
        return 111;
    case 5 : 
        return 95;
    case 6 : 
        return 63;
    
  }
}

function writeStr(a, str, idx, strLen) {
  arraySet(a, idx, strLen);
  var idx$1 = idx + 1 | 0;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i < strLen) {
      arraySet(a, idx$1 + i | 0, str.charCodeAt(i));
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return 0;
    }
  };
}

function writeInstr(a, func, instr, idx) {
  if (typeof instr === "number") {
    arraySet(a, idx, 106);
    return idx + 1 | 0;
  } else if (instr.tag) {
    arraySet(a, idx, 65);
    return List.fold_left((function (idx, b) {
                  arraySet(a, idx, b);
                  return idx + 1 | 0;
                }), idx + 1 | 0, Leb128.encodeS(instr[0]));
  } else {
    arraySet(a, idx, 32);
    arraySet(a, idx + 1 | 0, Hashtbl.find(func[/* localIdx */4], instr[0]));
    return idx + 2 | 0;
  }
}

function modul$1(modul$2) {
  var numFuncs = List.length(modul$2[/* funcs */0]);
  var estSize = (numFuncs << 8);
  var buf = makeBuf(estSize);
  var a = buf[/* arr */0];
  arraySet(a, 0, 0);
  arraySet(a, 1, 97);
  arraySet(a, 2, 115);
  arraySet(a, 3, 109);
  arraySet(a, 4, 1);
  arraySet(a, 8, 1);
  arraySet(a, 10, numFuncs);
  var idx = List.fold_left((function (idx, f) {
          arraySet(a, idx, 96);
          arraySet(a, idx + 1 | 0, f[/* numParams */7]);
          var idx$1 = List.fold_left((function (idx, p) {
                  arraySet(a, idx, typeCode(p[/* tpe */1]));
                  return idx + 1 | 0;
                }), idx + 2 | 0, f[/* params */1]);
          arraySet(a, idx$1, f[/* numReturns */9]);
          return List.fold_left((function (idx, tpe) {
                        arraySet(a, idx, typeCode(tpe));
                        return idx + 1 | 0;
                      }), idx$1 + 1 | 0, f[/* returns */2]);
        }), 11, modul$2[/* funcs */0]);
  arraySet(a, 9, (idx - 9 | 0) - 1 | 0);
  arraySet(a, idx, 3);
  arraySet(a, idx + 1 | 0, numFuncs + 1 | 0);
  arraySet(a, idx + 2 | 0, numFuncs);
  var match = List.fold_left((function (param, _) {
          var i = param[1];
          var idx = param[0];
          arraySet(a, idx, i);
          return /* tuple */[
                  idx + 1 | 0,
                  i + 1 | 0
                ];
        }), /* tuple */[
        idx + 3 | 0,
        0
      ], modul$2[/* funcs */0]);
  var idx$1 = match[0];
  arraySet(a, idx$1, 7);
  var exportSizeIdx = idx$1 + 1 | 0;
  var match$1 = List.fold_left((function (param, f) {
          var numExports = param[2];
          var i = param[1];
          var idx = param[0];
          if (f[/* export */6]) {
            var nameLen = f[/* name */0].length;
            arraySet(a, idx, nameLen);
            writeStr(a, f[/* name */0], idx + 1 | 0, nameLen);
            var idx$1 = (idx + nameLen | 0) + 2 | 0;
            arraySet(a, idx$1, 0);
            arraySet(a, idx$1 + 1 | 0, i);
            return /* tuple */[
                    idx$1 + 2 | 0,
                    i + 1 | 0,
                    numExports + 1 | 0
                  ];
          } else {
            return /* tuple */[
                    idx,
                    i + 1 | 0,
                    numExports
                  ];
          }
        }), /* tuple */[
        idx$1 + 2 | 0,
        0,
        0
      ], modul$2[/* funcs */0]);
  var idx$2 = match$1[0];
  arraySet(a, exportSizeIdx, (idx$2 - exportSizeIdx | 0) - 1 | 0);
  arraySet(a, exportSizeIdx + 1 | 0, match$1[2]);
  arraySet(a, idx$2, 10);
  var codeSizeIdx = idx$2 + 1 | 0;
  arraySet(a, idx$2 + 2 | 0, numFuncs);
  var idx$3 = List.fold_left((function (idx, f) {
          var numLocals = List.length(f[/* locals */3]);
          arraySet(a, idx + 1 | 0, numLocals);
          var idx$1 = List.fold_left((function (idx, instr) {
                  return writeInstr(a, f, instr, idx);
                }), idx + 2 | 0, f[/* instr */5]);
          arraySet(a, idx, idx$1 - idx | 0);
          arraySet(a, idx$1, 11);
          return idx$1 + 1 | 0;
        }), idx$2 + 3 | 0, modul$2[/* funcs */0]);
  arraySet(a, codeSizeIdx, (idx$3 - codeSizeIdx | 0) - 1 | 0);
  buf[/* size */1] = idx$3;
  return /* tuple */[
          buf[/* size */1],
          new Uint8Array(buf[/* buf */3], 0, buf[/* size */1])
        ];
}

var ToBin = /* module */[
  /* makeBuf */makeBuf,
  /* typeCode */typeCode,
  /* writeStr */writeStr,
  /* writeInstr */writeInstr,
  /* modul */modul$1
];

function instr(instr$1) {
  if (typeof instr$1 === "number") {
    return "i32.add ";
  } else if (instr$1.tag) {
    return "i32.const " + Pervasives.string_of_int(instr$1[0]);
  } else {
    return "get_local $" + instr$1[0];
  }
}

function tpe(tpe$1) {
  switch (tpe$1) {
    case 0 : 
        return "i32";
    case 1 : 
        return "i64";
    case 2 : 
        return "f32";
    case 3 : 
        return "f64";
    case 4 : 
        return "anyfunc";
    case 5 : 
        return "func";
    case 6 : 
        return "void";
    
  }
}

function func$1(func$2) {
  var s = "  (func $" + (func$2[/* name */0] + " ");
  var s$1 = List.fold_left((function (s, p) {
          return s + ("(param $" + (p[/* name */0] + (" " + (tpe(p[/* tpe */1]) + ") "))));
        }), s, func$2[/* params */1]);
  var s$2 = List.fold_left((function (s, r) {
          return s + ("(result " + (tpe(r) + ") "));
        }), s$1, func$2[/* returns */2]) + "\n";
  var s$3 = List.fold_left((function (s, inst) {
          return s + ("    " + (instr(inst) + "\n"));
        }), s$2, func$2[/* instr */5]);
  return s$3 + "  )\n";
}

function modul$2(modul$3) {
  var match = List.fold_left((function (param, f) {
          var e = param[1];
          return /* tuple */[
                  param[0] + func$1(f),
                  f[/* export */6] ? e + ("  (export \"" + (f[/* name */0] + ("\" (func $" + (f[/* name */0] + "))\n")))) : e
                ];
        }), /* tuple */[
        "(module\n",
        ""
      ], modul$3[/* funcs */0]);
  return match[0] + (match[1] + ")\n");
}

var ToSexp = /* module */[
  /* instr */instr,
  /* tpe */tpe,
  /* func */func$1,
  /* modul */modul$2
];

function printArr(a, size) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i < size) {
      console.log("adr", Utils.hexString(i), Utils.hexString(arrayGet(a, i)));
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return 0;
    }
  };
}

exports.param = param;
exports.func = func;
exports.modul = modul;
exports.ToBin = ToBin;
exports.ToSexp = ToSexp;
exports.printArr = printArr;
/* No side effect */
